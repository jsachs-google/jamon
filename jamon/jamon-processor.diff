Index: nodegen/nodes
===================================================================
--- nodegen/nodes	(.../releases/jamon-processor/jamon-processor-2.3.4)	(revision 2774)
+++ nodegen/nodes	(.../trunk/jamon/jamon-processor)	(revision 2774)
@@ -25,6 +25,7 @@
 ExtendsNode AbstractPathNode:path
 ImplementNode String:name
 ImplementsNode ImplementNode:implement*
+ReplacesNode AbstractPathNode:path
 AbstractImportNode String:name
 ImportNode:AbstractImportNode
 StaticImportNode:AbstractImportNode
Index: src/test/java/org/jamon/codegen/ArgumentTest.java
===================================================================
--- src/test/java/org/jamon/codegen/ArgumentTest.java	(.../releases/jamon-processor/jamon-processor-2.3.4)	(revision 0)
+++ src/test/java/org/jamon/codegen/ArgumentTest.java	(.../trunk/jamon/jamon-processor)	(revision 2774)
@@ -0,0 +1,47 @@
+package org.jamon.codegen;
+
+import static org.junit.Assert.*;
+
+import org.junit.Test;
+
+public class ArgumentTest {
+  private static final TemplateUnit TEMPLATE_UNIT =
+    new TemplateUnit("org/jamon/Template", null);
+
+  @Test
+  public void testGetFullyQualifiedTypeForRequiredArg() {
+    assertEquals("bar", new RequiredArgument("foo", "bar", null).getFullyQualifiedType());
+  }
+
+  @Test
+  public void testGetFullyQualifiedTypeForTopLevelFragmentArg() {
+    FragmentUnit fragmentUnit = new FragmentUnit(
+      "frag", TEMPLATE_UNIT, new GenericParams(), null, null);
+    FragmentArgument fragmentArgument = new FragmentArgument(fragmentUnit, null);
+    assertEquals("org.jamon.Template.Intf.Fragment_frag", fragmentArgument.getFullyQualifiedType());
+  }
+
+  @Test
+  public void testGetFullyQualifiedTypeForMethodFragmentArg() {
+    FragmentUnit fragmentUnit = new FragmentUnit(
+      "frag",
+      new DeclaredMethodUnit("method", TEMPLATE_UNIT, null, null),
+      new GenericParams(),
+      null,
+      null);
+    FragmentArgument fragmentArgument = new FragmentArgument(fragmentUnit, null);
+    assertEquals("Fragment_method__jamon__frag", fragmentArgument.getFullyQualifiedType());
+  }
+
+  @Test
+  public void testGetFullyQualifiedTypeForDefFragmentArg() {
+    FragmentUnit fragmentUnit = new FragmentUnit(
+      "frag",
+      new DefUnit("def", TEMPLATE_UNIT, null, null),
+      new GenericParams(),
+      null,
+      null);
+    FragmentArgument fragmentArgument = new FragmentArgument(fragmentUnit, null);
+    assertEquals("Fragment_def__jamon__frag", fragmentArgument.getFullyQualifiedType());
+  }
+}

Property changes on: src/test/java/org/jamon/codegen/ArgumentTest.java
___________________________________________________________________
Added: svn:mime-type
   + text/plain

Index: src/test/java/org/jamon/codegen/AnalyzerTest.java
===================================================================
--- src/test/java/org/jamon/codegen/AnalyzerTest.java	(.../releases/jamon-processor/jamon-processor-2.3.4)	(revision 2774)
+++ src/test/java/org/jamon/codegen/AnalyzerTest.java	(.../trunk/jamon/jamon-processor)	(revision 2774)
@@ -27,23 +27,31 @@
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.List;
+import java.util.Map;
 import java.util.Properties;
 
 import junit.framework.TestCase;
 
 import org.jamon.api.TemplateLocation;
 import org.jamon.api.TemplateSource;
+import org.jamon.compiler.ParserErrorImpl;
+import org.jamon.compiler.ParserErrorsImpl;
 import org.jamon.compiler.TemplateResourceLocation;
 import org.jamon.node.AnnotationNode;
 import org.jamon.node.LocationImpl;
 
+import com.google.common.base.Function;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.Maps;
+
 public class AnalyzerTest extends TestCase
 {
     public static class MockTemplateSource implements TemplateSource
     {
-        public MockTemplateSource(String p_content)
+        public MockTemplateSource(Map<String, String> p_content)
         {
-            m_bytes = p_content.getBytes();
+            m_bytes = Maps.transformValues(p_content, new Function<String, byte[]>() {
+                @Override public byte[] apply(String p_input) { return p_input.getBytes(); }});
         }
 
         public long lastModified(String p_templatePath)
@@ -53,12 +61,12 @@
 
         public boolean available(String p_templatePath)
         {
-            return false;
+            return m_bytes.containsKey(p_templatePath);
         }
 
         public InputStream getStreamFor(String p_templatePath)
         {
-            return new ByteArrayInputStream(m_bytes);
+            return new ByteArrayInputStream(m_bytes.get(p_templatePath));
         }
 
         public String getExternalIdentifier(String p_templatePath)
@@ -78,7 +86,7 @@
             p_properties.put("org.jamon.escape", "j");
         }
 
-        private final byte[] m_bytes;
+        private final Map<String, byte[]> m_bytes;
     }
 
     private static String PATH = "/test";
@@ -100,11 +108,7 @@
 
     private TemplateUnit analyzeText(String p_templateText) throws IOException
     {
-        return new Analyzer(
-            PATH,
-            new TemplateDescriber(new MockTemplateSource(p_templateText),
-                                  getClass().getClassLoader()))
-        .analyze();
+        return analyze(ImmutableMap.of(PATH, p_templateText));
     }
 
     private void checkLoopBlock(
@@ -191,14 +195,103 @@
         assertEquals(
             Arrays.asList(
                 new AnnotationNode(
-                    new LocationImpl(new TemplateResourceLocation(PATH), 1, 2),
+                    location(1, 2),
                     "@Foo ", AnnotationType.IMPL),
                 new AnnotationNode(
-                    new LocationImpl(new TemplateResourceLocation(PATH), 2, 1),
+                    location(2, 1),
                     "@Bar", AnnotationType.PROXY),
                 new AnnotationNode(
-                    new LocationImpl(new TemplateResourceLocation(PATH), 3, 1),
+                    location(3, 1),
                     "@Baz", AnnotationType.BOTH)),
             templateUnit.getAnnotations());
     }
+
+    public void testAbstractReplaces() throws Exception
+    {
+        TemplateUnit templateUnit = analyze(ImmutableMap.of(
+            PATH, "<%replaces /foo>",
+            "/foo", "")); // TemplateDescriber will need to see the source for /foo
+        assertEquals("/foo", templateUnit.getReplacedTemplatePath());
+    }
+
+    public void testAbstractReplacesError() throws Exception
+    {
+        analyzeExpectingErrors(
+            ImmutableMap.of(PATH, "<%abstract><%replaces /foo>"),
+            new ParserErrorImpl(
+                location(1, 12),
+                "an abstract template cannot replace another template"));
+    }
+
+    public void testMissingRequiredArgsInReplacement() throws Exception
+    {
+        analyzeExpectingErrors(
+            ImmutableMap.of(
+                PATH, "<%replaces /foo><%args>int i; int j;</%args>",
+                "/foo", ""),
+            new ParserErrorImpl(
+                location(1, 1),
+                "Replaced template contains no required argument named i"),
+            new ParserErrorImpl(
+                location(1, 1),
+                "Replaced template contains no required argument named j"));
+    }
+
+    public void testMissingFragsInReplacement() throws Exception
+    {
+        analyzeExpectingErrors(
+            ImmutableMap.of(
+                PATH, "<%replaces /foo><%frag f/>",
+                "/foo", ""),
+                new ParserErrorImpl(
+                    location(1,1),
+                    "Replaced template contains no fragment argument named f"));
+    }
+
+    public void testMissingOptionalArgsInReplacement() throws Exception
+    {
+        analyzeExpectingErrors(
+            ImmutableMap.of(
+                PATH, "<%replaces /foo><%args>int i = 1; int j = 2; int k = 3;</%args>",
+                "/foo", "<%args>int j = 2; int k;</%args>"),
+                new ParserErrorImpl(
+                    location(1, 1),
+                    "Replaced template contains no required or optional argument named i"));
+    }
+
+    public void testCircularInheritance() throws Exception
+    {
+        analyzeExpectingErrors(
+            ImmutableMap.of(PATH, "<%extends " + PATH + ">"),
+            new ParserErrorImpl(location(1, 1), "cyclic inheritance or replacement involving " + PATH));
+    }
+
+    public void testCircularReplacement() throws Exception
+    {
+        analyzeExpectingErrors(
+            ImmutableMap.of(PATH, "<%replaces " + PATH + ">"),
+            new ParserErrorImpl(location(1, 1), "cyclic inheritance or replacement involving " + PATH));
+    }
+
+    private void analyzeExpectingErrors(
+        Map<String, String> p_contents, ParserErrorImpl... p_errors) throws IOException
+    {
+        try {
+            analyze(p_contents);
+            fail("Exception expected");
+        }
+        catch (ParserErrorsImpl e)
+        {
+            assertEquals(Arrays.asList(p_errors), e.getErrors());
+        }
+    }
+
+    private TemplateUnit analyze(Map<String, String> p_contents) throws IOException {
+        return new Analyzer(PATH, new TemplateDescriber(
+            new MockTemplateSource(p_contents), getClass().getClassLoader())).analyze();
+    }
+
+    private LocationImpl location(int p_line, int p_column) {
+        return new LocationImpl(new TemplateResourceLocation(PATH), p_line, p_column);
+    }
 }
Index: src/test/java/org/jamon/codegen/TemplateUnitTest.java
===================================================================
--- src/test/java/org/jamon/codegen/TemplateUnitTest.java	(.../releases/jamon-processor/jamon-processor-2.3.4)	(revision 2774)
+++ src/test/java/org/jamon/codegen/TemplateUnitTest.java	(.../trunk/jamon/jamon-processor)	(revision 2774)
@@ -28,6 +28,7 @@
 
 import junit.framework.TestCase;
 
+import org.jamon.api.Location;
 import org.jamon.compiler.TemplateFileLocation;
 import org.jamon.node.ArgNameNode;
 import org.jamon.node.ArgValueNode;
@@ -40,6 +41,7 @@
 public class TemplateUnitTest
     extends TestCase
 {
+    private static final Location LOCATION = new LocationImpl(null, 1, 1);
 
     public void testInheritanceDepth() throws Exception
     {
@@ -76,7 +78,7 @@
         child.setParentPath(parent.getName());
         child.setParentDescription(new TemplateDescription(parent));
 
-        org.jamon.api.Location loc = new LocationImpl(new TemplateFileLocation("x"), 1,1);
+        Location loc = new LocationImpl(new TemplateFileLocation("x"), 1,1);
         child.addParentArg(new ParentArgNode(loc, new ArgNameNode(loc, "pr2")));
         child.addParentArg(new ParentArgWithDefaultNode(
             loc, new ArgNameNode(loc, "po2"), new ArgValueNode(loc, "oc2")));
@@ -156,15 +158,13 @@
         checkSigIsUnique(unit, sigs);
         unit.addFragmentArg(new FragmentArgument(g, null));
 
-        org.jamon.api.Location loc = new LocationImpl(null, 1, 1);
-        GenericsParamNode genericsParamNode = new GenericsParamNode(loc, "d");
+        GenericsParamNode genericsParamNode = new GenericsParamNode(LOCATION, "d");
         unit.addGenericsParamNode(genericsParamNode);
         checkSigIsUnique(unit, sigs);
-        genericsParamNode.addBound(new GenericsBoundNode(loc, "String"));
+        genericsParamNode.addBound(new GenericsBoundNode(LOCATION, "String"));
         checkSigIsUnique(unit, sigs);
     }
 
-
     public void testDependencies()
         throws Exception
     {
@@ -217,6 +217,18 @@
             .isOriginatingJamonContext());
     }
 
+    public void testGetProxyParentClassOfSimpleTemplate()
+    {
+        assertEquals(ClassNames.TEMPLATE, new TemplateUnit("/foo", null).getProxyParentClass());
+    }
+
+    public void testGetProxyParentClassOfChildTemlpate()
+    {
+        TemplateUnit child = new TemplateUnit("/child", null);
+        child.setParentPath("/Parent");
+        assertEquals("Parent", child.getProxyParentClass());
+    }
+
     private void checkSigIsUnique(TemplateUnit p_unit, Set<String> p_set)
         throws Exception
     {
Index: src/test/java/org/jamon/codegen/PathUtilsTest.java
===================================================================
--- src/test/java/org/jamon/codegen/PathUtilsTest.java	(.../releases/jamon-processor/jamon-processor-2.3.4)	(revision 0)
+++ src/test/java/org/jamon/codegen/PathUtilsTest.java	(.../trunk/jamon/jamon-processor)	(revision 2774)
@@ -0,0 +1,16 @@
+package org.jamon.codegen;
+
+import static org.junit.Assert.*;
+
+import org.junit.Test;
+
+public class PathUtilsTest
+{
+
+    @Test
+    public void testGetPathForProxyClass()
+    {
+        assertEquals("org/jamon/codegen/PathUtilsTest", PathUtils.getPathForProxyClass(getClass()));
+    }
+
+}

Property changes on: src/test/java/org/jamon/codegen/PathUtilsTest.java
___________________________________________________________________
Added: svn:mime-type
   + text/plain

Index: src/test/java/org/jamon/parser/ParserErrorsTest.java
===================================================================
--- src/test/java/org/jamon/parser/ParserErrorsTest.java	(.../releases/jamon-processor/jamon-processor-2.3.4)	(revision 2774)
+++ src/test/java/org/jamon/parser/ParserErrorsTest.java	(.../trunk/jamon/jamon-processor)	(revision 2774)
@@ -22,6 +22,14 @@
                     1, 15, AbstractParser.MALFORMED_TAG_ERROR);
     }
 
+    @Test public void testMalformedReplacesTag() throws Exception
+    {
+      assertError("<%replaces>",
+        1, 1, TopLevelParser.MALFORMED_REPLACES_TAG_ERROR);
+      assertError("<%replaces /foo f>",
+        1, 16, AbstractParser.MALFORMED_TAG_ERROR);
+    }
+
     @Test public void testMalformedAnnotateTag() throws Exception
     {
         assertError("<%annotate>",
@@ -214,6 +222,13 @@
             2, 1, AbstractBodyParser.IMPLEMENTS_TAG_IN_SUBCOMPONENT);
     }
 
+    @Test public void testReplacesInSubcomponent() throws Exception
+    {
+      assertError(
+        "<%def foo>\n<%replaces /foo></%def>",
+        2, 1, AbstractBodyParser.REPLACES_TAG_IN_SUBCOMPONENT);
+    }
+
     @Test public void testParentArgsInSubcomponent() throws Exception
     {
         assertError(
Index: src/main/java/org/jamon/codegen/AbstractUnit.java
===================================================================
--- src/main/java/org/jamon/codegen/AbstractUnit.java	(.../releases/jamon-processor/jamon-processor-2.3.4)	(revision 2774)
+++ src/main/java/org/jamon/codegen/AbstractUnit.java	(.../trunk/jamon/jamon-processor)	(revision 2774)
@@ -152,7 +152,7 @@
     {
         for (AbstractArgument arg: i)
         {
-            p_writer.printListElement("final " + arg.getType() + " " + arg.getName());
+            p_writer.printListElement("final " + arg.getFullyQualifiedType() + " " + arg.getName());
         }
     }
 
Index: src/main/java/org/jamon/codegen/FragmentArgument.java
===================================================================
--- src/main/java/org/jamon/codegen/FragmentArgument.java	(.../releases/jamon-processor/jamon-processor-2.3.4)	(revision 2774)
+++ src/main/java/org/jamon/codegen/FragmentArgument.java	(.../trunk/jamon/jamon-processor)	(revision 2774)
@@ -39,8 +39,13 @@
 
     private final FragmentUnit m_fragmentUnit;
 
-    @Override public String getType()
-    {
-        return super.getType();
+    @Override
+    public String getFullyQualifiedType() {
+        if (getFragmentUnit().getParent() instanceof TemplateUnit)
+        {
+            String templateName = ((TemplateUnit) getFragmentUnit().getParent()).getName();
+            return PathUtils.getFullyQualifiedIntfClassName(templateName) + ".Intf." + getType();
+        }
+        return getType();
     }
 }
Index: src/main/java/org/jamon/codegen/TemplateUnit.java
===================================================================
--- src/main/java/org/jamon/codegen/TemplateUnit.java	(.../releases/jamon-processor/jamon-processor-2.3.4)	(revision 2774)
+++ src/main/java/org/jamon/codegen/TemplateUnit.java	(.../trunk/jamon/jamon-processor)	(revision 2774)
@@ -295,6 +295,45 @@
         return m_parentPath != null;
     }
 
+    /**
+     * Set the path of the template which this template replaces, along with the description of
+     * the replaced template.
+     * @param p_replacedTemplatePath the path of the template which this template replaced
+     * @param p_templateDescription the description of the replaced template
+     */
+    public void setReplacedTemplatePath(
+        String p_replacedTemplatePath, TemplateDescription p_templateDescription) {
+        m_replacedTemplatePath = p_replacedTemplatePath;
+        m_replacedTemplateDescription = p_templateDescription;
+        m_dependencies.add(p_replacedTemplatePath);
+    }
+
+    public String getReplacedTemplatePath()
+    {
+        return m_replacedTemplatePath;
+    }
+
+    public TemplateDescription getReplacedTemplateDescription() {
+        return m_replacedTemplateDescription;
+    }
+
+    /**
+     * Whether this template replaces another template. This is the case if the template has a
+     * {@code <%replacesTemplate ...>} tag.
+     * @return {@code true} if this template replaces another template.
+     */
+    public boolean isReplacing()
+    {
+        return m_replacedTemplatePath != null;
+    }
+
+    public String getProxyParentClass()
+    {
+        return  hasParentPath()
+             ? PathUtils.getFullyQualifiedIntfClassName(getParentPath())
+             :ClassNames.TEMPLATE;
+    }
+
     public boolean isParent()
     {
         return m_isParent;
@@ -347,6 +386,8 @@
     private final List<String> m_interfaces = new LinkedList<String>();
     private String m_parentPath;
     private boolean m_isParent = false;
+    private String m_replacedTemplatePath;
+    private TemplateDescription m_replacedTemplateDescription;
     private final List<ClassNode> m_classContent = new LinkedList<ClassNode>();
     private final Set<String> m_dependencies = new HashSet<String>();
     private final Set<String> m_callNames = new HashSet<String>();
@@ -445,6 +486,11 @@
         }
     }
 
+    /**
+     * Get the signature hash for this template. The signature is a hash which will change in the
+     * event that the template's API has changed.
+     * @return the signature hash for this template
+     */
     public String getSignature()
     {
         try
@@ -493,6 +539,6 @@
 
     public Iterable<AnnotationNode> getAnnotations()
     {
-        return m_annotations; 
+        return m_annotations;
     }
 }
Index: src/main/java/org/jamon/codegen/PathUtils.java
===================================================================
--- src/main/java/org/jamon/codegen/PathUtils.java	(.../releases/jamon-processor/jamon-processor-2.3.4)	(revision 2774)
+++ src/main/java/org/jamon/codegen/PathUtils.java	(.../trunk/jamon/jamon-processor)	(revision 2774)
@@ -131,6 +131,15 @@
     }
 
     /**
+     * Given a proxy class, return the corresponding template path.
+     * @param p_class the proxy class
+     * @return the corresponding template path
+     */
+    public static String getPathForProxyClass(Class<?> p_class) {
+      return p_class.getName().replace(".", "/");
+    }
+
+    /**
      * Fully qualify a class name given a package name and class name.
      *
      * @param p_pkgName the name of the package
Index: src/main/java/org/jamon/codegen/Analyzer.java
===================================================================
--- src/main/java/org/jamon/codegen/Analyzer.java	(.../releases/jamon-processor/jamon-processor-2.3.4)	(revision 2774)
+++ src/main/java/org/jamon/codegen/Analyzer.java	(.../trunk/jamon/jamon-processor)	(revision 2774)
@@ -21,6 +21,8 @@
 package org.jamon.codegen;
 
 import java.io.IOException;
+import java.util.Collection;
+import java.util.Iterator;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
@@ -68,6 +70,7 @@
         preAnalyze(top);
         mainAnalyze(top);
         checkForConcreteness(top);
+        checkTemplateReplacement(top);
         if (m_errors.hasErrors())
         {
             throw m_errors;
@@ -108,7 +111,7 @@
         p_top.apply(new Adapter());
     }
 
-    public void checkForConcreteness(TopNode p_top)
+    private void checkForConcreteness(TopNode p_top)
     {
         if (! getTemplateUnit().isParent()
             && ! getTemplateUnit().getAbstractMethodNames().isEmpty())
@@ -129,6 +132,104 @@
         }
     }
 
+    /**
+     * If this template is a replacement template (via the <%replaces> tag), verify that:
+     * <ul>
+     *   <li>The replacing template is concrete</li>
+     *   <li>All required arguments have matching required arguments in the replaced template</li>
+     *   <li>All optional argument have matching required or optional arguments in the replaced
+     *       template</li>
+     *   <li>All fragment arguments have matching fragment arguments in the replaced template</li>
+     * </li>
+     * @param p_top the top node of the syntax tree.
+     */
+    private void checkTemplateReplacement(TopNode p_top) {
+        topLevelAnalyze(p_top, new AnalysisAdapter()
+            {
+                @Override
+                public void caseReplacesNode(ReplacesNode p_replaces)
+                {
+                    if(getTemplateUnit().isParent())
+                    {
+                        addError(
+                          "an abstract template cannot replace another template",
+                          p_replaces.getLocation());
+                    }
+                    else
+                    {
+                        String replacedTemplatePath =
+                            getAbsolutePath(computePath(p_replaces.getPath()));
+                        //FIXME: verify that the replaced template is not abstract.
+                        TemplateDescription replacedTemplateDescription =
+                            getTemplateDescription(replacedTemplatePath, p_replaces.getLocation());
+                        if (replacedTemplateDescription != null) {
+                            getTemplateUnit().setReplacedTemplatePath(
+                                replacedTemplatePath, replacedTemplateDescription);
+                            verifyRequiredArgsComeFromReplacedTemplate(
+                                p_replaces.getLocation(), replacedTemplateDescription);
+                            verifyFragmentArgsComeFromReplacedTemplate(
+                                p_replaces.getLocation(), replacedTemplateDescription);
+                            verifyOptionalArgsComeFromReplacedTemplate(
+                                p_replaces.getLocation(), replacedTemplateDescription);
+                        }
+                    }
+                }
+            });
+    }
+
+    private void verifyRequiredArgsComeFromReplacedTemplate(
+        Location p_location, TemplateDescription p_replacedTemplateDescription)
+    {
+        verifyArgsComeFromReplacedTemplate(
+            p_location,
+            p_replacedTemplateDescription.getRequiredArgs().iterator(),
+            getTemplateUnit().getSignatureRequiredArgs(),
+            "required");
+    }
+
+    private void verifyFragmentArgsComeFromReplacedTemplate(
+        Location p_location, TemplateDescription p_replacedTemplateDescription)
+    {
+        verifyArgsComeFromReplacedTemplate(
+            p_location,
+            p_replacedTemplateDescription.getFragmentInterfaces().iterator(),
+            getTemplateUnit().getFragmentArgs(),
+            "fragment");
+    }
+
+    private void verifyOptionalArgsComeFromReplacedTemplate(
+        Location p_location, TemplateDescription p_replacedTemplateDescription)
+    {
+        verifyArgsComeFromReplacedTemplate(
+            p_location,
+            new SequentialIterator<AbstractArgument>(
+                p_replacedTemplateDescription.getRequiredArgs().iterator(),
+                p_replacedTemplateDescription.getOptionalArgs().iterator()),
+            getTemplateUnit().getSignatureOptionalArgs(),
+            "required or optional");
+    }
+
+    private <T extends AbstractArgument> void verifyArgsComeFromReplacedTemplate(
+        Location p_location,
+        Iterator<T> replacedTemplateArgs,
+        Collection<? extends T> templateArgs,
+        String argumentKind)
+    {
+        Set<String> replacedTemplateArgNames = new HashSet<String>();
+        while (replacedTemplateArgs.hasNext()) {
+            replacedTemplateArgNames.add(replacedTemplateArgs.next().getName());
+        }
+
+        for (T arg: templateArgs) {
+            if (! replacedTemplateArgNames.contains(arg.getName())) {
+                addError(
+                    "Replaced template contains no " + argumentKind + " argument named "
+                    + arg.getName(),
+                    p_location);
+            }
+        }
+    }
+
     private void pushDefUnit(String p_defName)
     {
         m_currentStatementBlock = getTemplateUnit().getDefUnit(p_defName);
@@ -284,36 +385,11 @@
             String parentPath =
                 getAbsolutePath(computePath(p_extends.getPath()));
             getTemplateUnit().setParentPath(parentPath);
-            if (m_children.contains(parentPath))
-            {
-                addError(
-                    "cyclic inheritance involving " + parentPath,
-                    p_extends.getLocation());
+            TemplateDescription parentDescription =
+                getTemplateDescription(parentPath, p_extends.getLocation());
+            if (parentDescription != null) {
+                getTemplateUnit().setParentDescription(parentDescription);
             }
-            else
-            {
-                m_children.add(parentPath);
-                try
-                {
-                    getTemplateUnit().setParentDescription(
-                        m_describer.getTemplateDescription(
-                            parentPath,
-                            p_extends.getLocation(),
-                            m_children));
-                }
-                catch (ParserErrorImpl e)
-                {
-                    m_errors.addError(e);
-                }
-                catch (ParserErrorsImpl e)
-                {
-                    m_errors.addErrors(e);
-                }
-                catch (IOException e)
-                {
-                    addError(e.getMessage(), p_extends.getLocation());
-                }
-            }
         }
 
         @Override public void caseAnnotationNode(AnnotationNode p_node)
@@ -798,4 +874,38 @@
     {
         getCurrentStatementBlock().addStatement(p_statement);
     }
+
+    private TemplateDescription getTemplateDescription(String p_path, Location p_location)
+    {
+        if (m_children.contains(p_path))
+        {
+            addError(
+                "cyclic inheritance or replacement involving " + p_path, p_location);
+            return null;
+        }
+        else
+        {
+            m_children.add(p_path);
+            try
+            {
+                return m_describer.getTemplateDescription(
+                        p_path,
+                        p_location,
+                        m_children);
+            }
+            catch (ParserErrorImpl e)
+            {
+                m_errors.addError(e);
+            }
+            catch (ParserErrorsImpl e)
+            {
+                m_errors.addErrors(e);
+            }
+            catch (IOException e)
+            {
+                addError(e.getMessage(), p_location);
+            }
+            return null;
+        }
+    }
 }
Index: src/main/java/org/jamon/codegen/ClassNames.java
===================================================================
--- src/main/java/org/jamon/codegen/ClassNames.java	(.../releases/jamon-processor/jamon-processor-2.3.4)	(revision 2774)
+++ src/main/java/org/jamon/codegen/ClassNames.java	(.../trunk/jamon/jamon-processor)	(revision 2774)
@@ -32,6 +32,7 @@
         org.jamon.AbstractTemplateProxy.class.getName();
     public final static String TEMPLATE_INTF = TEMPLATE + ".Intf";
     public final static String IMPL_DATA = TEMPLATE + ".ImplData";
+    public final static String IMPL_DATA_COMPATIBLE = TEMPLATE + ".ImplDataCompatible";
     public final static String TEMPLATE_MANAGER =
         org.jamon.TemplateManager.class.getName();
     public static final String BASE_TEMPLATE =
Index: src/main/java/org/jamon/codegen/FragmentUnit.java
===================================================================
--- src/main/java/org/jamon/codegen/FragmentUnit.java	(.../releases/jamon-processor/jamon-processor-2.3.4)	(revision 2774)
+++ src/main/java/org/jamon/codegen/FragmentUnit.java	(.../trunk/jamon/jamon-processor)	(revision 2774)
@@ -20,13 +20,18 @@
 
 package org.jamon.codegen;
 
+import org.jamon.api.Location;
 import org.jamon.compiler.ParserErrorsImpl;
 import org.jamon.node.OptionalArgNode;
 
 public class FragmentUnit extends AbstractInnerUnit
 {
-    public FragmentUnit(String p_name, StatementBlock p_parent,
-                        GenericParams p_genericParams, ParserErrorsImpl p_errors, org.jamon.api.Location p_location)
+    public FragmentUnit(
+        String p_name,
+        StatementBlock p_parent,
+        GenericParams p_genericParams,
+        ParserErrorsImpl p_errors,
+        Location p_location)
     {
         super(p_name, p_parent, p_errors, p_location);
         m_genericParams = p_genericParams;
Index: src/main/java/org/jamon/codegen/AbstractArgument.java
===================================================================
--- src/main/java/org/jamon/codegen/AbstractArgument.java	(.../releases/jamon-processor/jamon-processor-2.3.4)	(revision 2774)
+++ src/main/java/org/jamon/codegen/AbstractArgument.java	(.../trunk/jamon/jamon-processor)	(revision 2774)
@@ -49,6 +49,15 @@
         return m_type;
     }
 
+    /**
+     * Return the fully qualified type. This will always be the same as the result of
+     * {@link #getType()}, except for top-level fragement arguments.
+     * @return the type, or for a top-level fragment argument, the fully qualified type.
+     */
+    public String getFullyQualifiedType() {
+      return getType();
+    }
+
     public org.jamon.api.Location getLocation()
     {
         return m_location;
@@ -68,16 +77,16 @@
     {
         p_writer.printLocation(getLocation());
         p_writer.println( "public void " + getSetterName()
-                          + "(" + getType() + " " + getName() + ")");
+                          + "(" + getFullyQualifiedType() + " " + getName() + ")");
         p_writer.openBlock();
         generateImplDataSetterCode(p_writer);
         p_writer.closeBlock();
 
-        p_writer.println("public " + getType() + " " + getGetterName() + "()");
+        p_writer.println("public " + getFullyQualifiedType() + " " + getGetterName() + "()");
         p_writer.openBlock();
         p_writer.println("return m_" + getName() + ";");
         p_writer.closeBlock();
-        p_writer.println("private " + getType() + " m_" + getName() + ";");
+        p_writer.println("private " + getFullyQualifiedType() + " m_" + getName() + ";");
     }
 
     protected void generateImplDataSetterCode(CodeWriter p_writer)
Index: src/main/java/org/jamon/codegen/TemplateDescription.java
===================================================================
--- src/main/java/org/jamon/codegen/TemplateDescription.java	(.../releases/jamon-processor/jamon-processor-2.3.4)	(revision 2774)
+++ src/main/java/org/jamon/codegen/TemplateDescription.java	(.../trunk/jamon/jamon-processor)	(revision 2774)
@@ -100,8 +100,10 @@
 
         m_requiredArgs = getRequiredArgs(templateAnnotation.requiredArguments());
         m_optionalArgs = getOptionalArgs(templateAnnotation.optionalArguments());
+
         m_fragmentInterfaces = getFragmentArguments(
-            templateAnnotation.fragmentArguments(), new TemplateUnit(null, null));
+            templateAnnotation.fragmentArguments(),
+            new TemplateUnit(PathUtils.getPathForProxyClass(p_proxy), null));
         m_methodUnits = new HashMap<String, MethodUnit>();
         for (Method methodAnnotation: templateAnnotation.methods())
         {
@@ -193,6 +195,11 @@
         return m_optionalArgs;
     }
 
+    /**
+     * Get the signature hash for the described template. The signature is a
+     * hash which will change in the event that the template's API has changed.
+     * @return the signature hash for this template
+     */
     public String getSignature()
     {
         return m_signature;
Index: src/main/java/org/jamon/codegen/ProxyGenerator.java
===================================================================
--- src/main/java/org/jamon/codegen/ProxyGenerator.java	(.../releases/jamon-processor/jamon-processor-2.3.4)	(revision 2774)
+++ src/main/java/org/jamon/codegen/ProxyGenerator.java	(.../trunk/jamon/jamon-processor)	(revision 2774)
@@ -22,6 +22,8 @@
 
 import java.io.OutputStream;
 import java.util.Collection;
+import java.util.HashSet;
+import java.util.Set;
 
 public class ProxyGenerator extends AbstractSourceGenerator
 {
@@ -51,9 +53,11 @@
         generateFragmentInterfaces(false);
         if (! m_templateUnit.isParent())
         {
-            generateConstructImpl();
+            generateConstructImplReflective();
+            generateConstructImplDirect();
             generateMakeRenderer();
             generateRender();
+            generateRenderNoFlush();
         }
         if (m_templateUnit.isParent())
         {
@@ -114,16 +118,17 @@
         m_writer.closeBlock();
 
         m_writer.println();
-        if (m_templateUnit.isParent())
+
+        // We require a pass-through constructor for child templates and for replacement templates,
+        // meaning that every proxy needs one.
+        m_writer.println("protected " + getClassName() + "(String p_path)");
+        m_writer.openBlock();
+        m_writer.println("super(p_path);");
+        m_writer.closeBlock();
+        m_writer.println();
+
+        if (! m_templateUnit.isParent())
         {
-            m_writer.println("protected " + getClassName() + "(String p_path)");
-            m_writer.openBlock();
-            m_writer.println("super(p_path);");
-            m_writer.closeBlock();
-            m_writer.println();
-        }
-        else
-        {
             m_writer.println("public " + getClassName() + "()");
             m_writer.openBlock();
             m_writer.println(" super(\"" + m_templateUnit.getName() + "\");");
@@ -255,16 +260,12 @@
             "class " + getClassName()
             + m_templateUnit.getGenericParams().generateGenericsDeclaration());
 
-        m_writer.println("  extends "
-                         + (m_templateUnit.hasParentPath()
-                            ? PathUtils.getFullyQualifiedIntfClassName(
-                                m_templateUnit.getParentPath())
-                            : ClassNames.TEMPLATE));
+        m_writer.println("  extends " + m_templateUnit.getProxyParentClass());
         m_templateUnit.printInterfaces(m_writer);
         m_writer.openBlock();
     }
 
-    private void generateConstructImpl()
+    private void generateConstructImplReflective()
     {
         m_writer.println();
         m_writer.println("@Override");
@@ -280,7 +281,7 @@
                          + ClassNames.TEMPLATE_MANAGER + ".class"
                          + ", ImplData.class })");
         m_writer.println(
-            ".newInstance(new Object [] { getTemplateManager(), getImplData()});");
+            ".newInstance(new Object [] { getTemplateManager(), getTypedImplData()});");
         m_writer.outdent();
         m_writer.closeBlock();
         m_writer.println("catch (RuntimeException e)");
@@ -292,7 +293,10 @@
         m_writer.println("throw new RuntimeException(e);");
         m_writer.closeBlock();
         m_writer.closeBlock();
+    }
 
+    private void generateConstructImplDirect()
+    {
         m_writer.println();
         m_writer.println("@Override");
         m_writer.print("protected " + ClassNames.BASE_TEMPLATE
@@ -300,9 +304,8 @@
         m_writer.openBlock();
         m_writer.println(
             "return new "
-            + PathUtils.getImplClassName(m_templateUnit.getName())
-            + m_templateUnit.getGenericParams().generateGenericParamsList()
-            + "(getTemplateManager(), getImplData());");
+            + PathUtils.getImplClassName(m_templateUnit.getName()) + genericParamsList()
+            + "(getTemplateManager(), getTypedImplData());");
         m_writer.closeBlock();
     }
 
@@ -326,7 +329,10 @@
         m_writer.println(";");
         m_writer.println(ArgNames.WRITER + ".flush();");
         m_writer.closeBlock();
+    }
 
+    private void generateRenderNoFlush()
+    {
         m_writer.print((m_templateUnit.isParent() ? "protected" : "public")
                        + " void renderNoFlush");
         m_writer.openList();
@@ -339,10 +345,7 @@
         m_writer.openBlock();
         if (! m_templateUnit.getRenderArgs().isEmpty())
         {
-            m_writer.println(
-                "ImplData"
-                + m_templateUnit.getGenericParams().generateGenericParamsList()
-                + " implData = getImplData();");
+            m_writer.println("ImplData" + genericParamsList() + " implData = getTypedImplData();");
             for (AbstractArgument arg: m_templateUnit.getRenderArgs())
             {
                 m_writer.println("implData." + arg.getSetterName()
@@ -397,17 +400,16 @@
             "public static class ImplData"
             + m_templateUnit.getGenericParams().generateGenericsDeclaration());
         m_writer.print("  extends ");
-        if(m_templateUnit.hasParentPath())
-        {
-            m_writer.println(PathUtils.getFullyQualifiedIntfClassName(
-                m_templateUnit.getParentPath())
-                             + ".ImplData");
+        m_writer.println(implDataAncestor());
+        if (m_templateUnit.isReplacing()) {
+            m_writer.print("  implements ");
+            m_writer.print(ClassNames.IMPL_DATA_COMPATIBLE);
+            m_writer.println("<" + getReplacedImplDataClassName() + ">");
         }
-        else
-        {
-            m_writer.println(ClassNames.IMPL_DATA);
+        m_writer.openBlock();
+        if (m_templateUnit.isReplacing()) {
+            generatePopulateFrom();
         }
-        m_writer.openBlock();
         if (m_templateUnit.isOriginatingJamonContext())
         {
             m_writer.println(
@@ -436,30 +438,172 @@
         if (! m_templateUnit.isParent())
         {
             m_writer.println("@Override");
-            m_writer.println(
-                "protected ImplData"
-                + m_templateUnit.getGenericParams().generateGenericParamsList()
-                + " makeImplData()");
+            m_writer.println("protected " + ClassNames.TEMPLATE + ".ImplData" + " makeImplData()");
             m_writer.openBlock();
-            m_writer.println(
-                "return new ImplData"
-                + m_templateUnit.getGenericParams().generateGenericParamsList()
-                             + "();");
+            m_writer.println("return new ImplData" + genericParamsList() + "();");
             m_writer.closeBlock();
         }
 
+        // Only generate the getTypedImplData method if we're actually going to use it.
+        if (! m_templateUnit.isParent()
+            || ! m_templateUnit.getSignatureOptionalArgs().isEmpty()
+            || m_templateUnit.getJamonContextType() != null) {
+            generateGetTypedImplData();
+        }
+    }
+
+    /**
+     * Generate a method to cast getImplData() to the ImplData class defined in this Proxy file.
+     */
+    private void generateGetTypedImplData()
+    {
         m_writer.println(
-            "@Override @SuppressWarnings(\"unchecked\") public ImplData"
-            + m_templateUnit.getGenericParams().generateGenericParamsList()
-            + " getImplData()");
+            "@SuppressWarnings(\"unchecked\") private ImplData" + genericParamsList()
+            + " getTypedImplData()");
         m_writer.openBlock();
-        m_writer.println(
-            "return (ImplData"
-            + m_templateUnit.getGenericParams().generateGenericParamsList()
-            + ") super.getImplData();");
+        m_writer.println("return (ImplData" + genericParamsList() + ") getImplData();");
         m_writer.closeBlock();
     }
 
+    /**
+     * Generate the populateFrom method, which is used in replacement templates to populate
+     * the template's ImplData instance with an instance of ImplData for the replaced template.
+     */
+    private void generatePopulateFrom()
+    {
+        for (FragmentArgument farg: m_templateUnit.getFragmentArgs()) {
+            generateFragmentDelegator(farg);
+        }
+        m_writer.print(
+            "public void populateFrom(" + getReplacedImplDataClassName() + " implData) ");
+        m_writer.openBlock();
+        TemplateDescription replacedTemplateDescription =
+            m_templateUnit.getReplacedTemplateDescription();
+        for (RequiredArgument arg: m_templateUnit.getSignatureRequiredArgs()) {
+            m_writer.println(arg.getSetterName() + "(implData." + arg.getGetterName() + "());");
+        }
+        Set<String> replacedTemplateOptionalArgNames =
+            getOptionalArgNames(replacedTemplateDescription);
+        for (OptionalArgument arg: replacedTemplateDescription.getOptionalArgs()) {
+            if (replacedTemplateOptionalArgNames.contains(arg.getName())) {
+                m_writer.println("if(implData." + arg.getIsNotDefaultName() + "()) {");
+                m_writer.println(
+                    "  " + arg.getSetterName() + "(implData." + arg.getGetterName() + "());");
+                m_writer.println("}");
+            }
+            else {
+                m_writer.println(
+                    arg.getSetterName() + "(implData." + arg.getGetterName() + "());");
+            }
+        }
+        for (FragmentArgument farg: m_templateUnit.getFragmentArgs()) {
+            m_writer.println(
+                farg.getSetterName()
+                + "(new " + getFragmentDelegatorName(farg) + genericParamsList()
+                + "(implData." + farg.getGetterName() + "()));");
+        }
+        m_writer.closeBlock();
+    }
+
+    /**
+     * Create a class to delegate from a fragment satisfying the interface for
+     * the replaced template to a fragment satisfying the corresponding
+     * interface in this template.
+     * @param farg the fragment argument to create a delegator for.
+     */
+    private void generateFragmentDelegator(FragmentArgument farg)
+    {
+        String fragmentInterfaceName = "Intf.Fragment_" + farg.getName() + genericParamsList();
+        String replacedFragmentInterfaceName =
+            getReplacedProxyClassName() + "." + fragmentInterfaceName;
+        FragmentUnit fragmentUnit = farg.getFragmentUnit();
+        // name the fragment being converted "_frag_" to avoid name clashes with the parameters
+        // passed to the fragment.
+        m_writer.print(
+            "private static class " + getFragmentDelegatorName(farg)
+            + m_templateUnit.getGenericParams().generateGenericsDeclaration()
+            + " implements " + fragmentInterfaceName);
+        m_writer.openBlock();
+        m_writer.println("private final " + replacedFragmentInterfaceName + " frag;");
+        m_writer.println();
+
+        m_writer.print(
+            "public " + getFragmentDelegatorName(farg)
+            + "(" + replacedFragmentInterfaceName + " frag)");
+        m_writer.openBlock();
+        m_writer.println("this.frag = frag;");
+        m_writer.closeBlock();
+        m_writer.println();
+        m_writer.print("public void renderNoFlush");
+        m_writer.openList();
+        m_writer.printListElement(ArgNames.WRITER_DECL);
+        fragmentUnit.printRenderArgsDecl(m_writer);
+        m_writer.closeList();
+        m_writer.println();
+        m_writer.println("  throws java.io.IOException");
+        m_writer.openBlock();
+        m_writer.print("this.frag.renderNoFlush");
+        m_writer.openList();
+        m_writer.printListElement(ArgNames.WRITER);
+        fragmentUnit.printRenderArgs(m_writer);
+        m_writer.closeList();
+        m_writer.println(";");
+        m_writer.closeBlock();
+
+        m_writer.print("public " + ClassNames.RENDERER + " makeRenderer");
+        m_writer.openList();
+        fragmentUnit.printRenderArgsDecl(m_writer);
+        m_writer.closeList();
+        m_writer.openBlock();
+        m_writer.print("return this.frag.makeRenderer");
+        m_writer.openList();
+        fragmentUnit.printRenderArgs(m_writer);
+        m_writer.closeList();
+        m_writer.println(";");
+        m_writer.closeBlock();
+
+        m_writer.closeBlock();
+        m_writer.println();
+    }
+
+    private String getFragmentDelegatorName(FragmentArgument farg) {
+        return "Fragment_" + farg.getName() + "_Delegator";
+    }
+
+    private String getReplacedImplDataClassName()
+    {
+        return getReplacedProxyClassName() + ".ImplData" + genericParamsList();
+    }
+
+    private String getReplacedIntfClassName()
+    {
+        return getReplacedProxyClassName() + ".Intf" + genericParamsList();
+    }
+
+    private String getReplacedProxyClassName()
+    {
+        return PathUtils.getFullyQualifiedIntfClassName(
+            m_templateUnit.getReplacedTemplatePath());
+    }
+
+    private static Set<String> getOptionalArgNames(
+        TemplateDescription p_replacedTemplateDescription)
+    {
+        Set<String> replacedTemplateOptionalArgNames = new HashSet<String>();
+        for (OptionalArgument arg: p_replacedTemplateDescription.getOptionalArgs()) {
+            replacedTemplateOptionalArgNames.add(arg.getName());
+        }
+        return replacedTemplateOptionalArgNames;
+    }
+
+    private String implDataAncestor()
+    {
+        return m_templateUnit.hasParentPath() ?
+            PathUtils.getFullyQualifiedIntfClassName(
+                m_templateUnit.getParentPath()) + ".ImplData"
+            : ClassNames.IMPL_DATA;
+    }
+
     private void generateJamonContextSetter()
     {
         m_writer.println();
@@ -473,7 +617,7 @@
             " setJamonContext(" + m_templateUnit.getJamonContextType()
             + " p_jamonContext)");
         m_writer.openBlock();
-        m_writer.println("getImplData().setJamonContext(p_jamonContext);");
+        m_writer.println("getTypedImplData().setJamonContext(p_jamonContext);");
         m_writer.println("return this;");
         m_writer.closeBlock();
     }
@@ -492,7 +636,7 @@
                 + "(" + arg.getType() +" p_" + arg.getName() + ")");
             m_writer.openBlock();
             m_writer.println(
-                "(" + "getImplData()" + ")."
+                "(" + "getTypedImplData()" + ")."
                 + arg.getSetterName() + "(p_" + arg.getName() + ");");
             m_writer.println("return this;");
             m_writer.closeBlock();
@@ -507,7 +651,7 @@
             m_writer.print(pkgName + ".");
         }
         m_writer.print(getClassName());
-        m_writer.print(m_templateUnit.getGenericParams().generateGenericsDeclaration());
+        m_writer.print(genericParamsList());
     }
 
     private void generateIntf()
@@ -515,13 +659,17 @@
         m_templateUnit.getGenericParams()
             .suppressGenericHidingWarnings(m_writer);
         m_writer.println(
-            "protected interface Intf"
+            "public interface Intf"
             + m_templateUnit.getGenericParams().generateGenericsDeclaration());
         m_writer.print("  extends "
                        + (m_templateUnit.hasParentPath()
                           ? PathUtils.getFullyQualifiedIntfClassName(
                               m_templateUnit.getParentPath()) + ".Intf"
                           : ClassNames.TEMPLATE_INTF));
+        if (m_templateUnit.isReplacing()) {
+            m_writer.print(", " + getReplacedIntfClassName());
+        }
+        m_writer.println();
         m_writer.openBlock();
 
         generateFragmentInterfaces(true);
@@ -668,4 +816,9 @@
         m_writer.println();
         m_writer.closeBlock();
     }
+
+    private String genericParamsList()
+    {
+        return m_templateUnit.getGenericParams().generateGenericParamsList();
+    }
 }
Index: src/main/java/org/jamon/parser/TopLevelParser.java
===================================================================
--- src/main/java/org/jamon/parser/TopLevelParser.java	(.../releases/jamon-processor/jamon-processor-2.3.4)	(revision 2774)
+++ src/main/java/org/jamon/parser/TopLevelParser.java	(.../trunk/jamon/jamon-processor)	(revision 2774)
@@ -37,6 +37,7 @@
 import org.jamon.node.ExtendsNode;
 import org.jamon.node.ImplementNode;
 import org.jamon.node.ImplementsNode;
+import org.jamon.node.ReplacesNode;
 import org.jamon.node.ImportsNode;
 import org.jamon.node.LocationImpl;
 import org.jamon.node.ParentMarkerNode;
@@ -50,6 +51,8 @@
     public static final String EXPECTING_ARROW = "Expecting '=' or '=>'";
     public static final String MALFORMED_EXTENDS_TAG_ERROR =
         "Malformed <%extends ...> tag";
+    public static final String MALFORMED_REPLACES_TAG_ERROR =
+        "Malformed <%replaces ...> tag";
     public static final String MALFORMED_ANNOTATE_TAG_ERROR =
         "Malformed <%annotate...> tag";
     public static final String UNRECOGNIZED_ANNOTATION_TYPE_ERROR =
@@ -170,6 +173,23 @@
         }
     }
 
+    @Override protected void handleReplacesTag(org.jamon.api.Location p_tagLocation)
+    throws IOException
+    {
+      if(soakWhitespace())
+      {
+        m_root.addSubNode(
+          new ReplacesNode(p_tagLocation, parsePath()));
+        soakWhitespace();
+        checkForTagClosure(m_reader.getLocation());
+        soakWhitespace();
+      }
+      else
+      {
+        addError(p_tagLocation, MALFORMED_REPLACES_TAG_ERROR);
+      }
+    }
+
     @Override protected void handleImplementsTag(org.jamon.api.Location p_tagLocation)
         throws IOException
     {
Index: src/main/java/org/jamon/parser/AbstractBodyParser.java
===================================================================
--- src/main/java/org/jamon/parser/AbstractBodyParser.java	(.../releases/jamon-processor/jamon-processor-2.3.4)	(revision 2774)
+++ src/main/java/org/jamon/parser/AbstractBodyParser.java	(.../trunk/jamon/jamon-processor)	(revision 2774)
@@ -23,6 +23,7 @@
 import java.util.ArrayList;
 import java.util.List;
 
+import org.jamon.api.Location;
 import org.jamon.compiler.ParserErrorImpl;
 import org.jamon.compiler.ParserErrorsImpl;
 import org.jamon.node.AbstractBodyNode;
@@ -72,6 +73,8 @@
         "<%aliases> sections only allowed at the top level of a document";
     public static final String IMPLEMENTS_TAG_IN_SUBCOMPONENT =
         "<%implements> sections only allowed at the top level of a document";
+    public static final String REPLACES_TAG_IN_SUBCOMPONENT =
+      "<%replaces ...> tag only allowed at the top level of a document";
     private static final String IMPORT_TAG_IN_SUBCOMPONENT =
         "<%import> sections only allowed at the top level of a document";
     public static final String PARENT_ARGS_TAG_IN_SUBCOMPONENT =
@@ -394,6 +397,9 @@
         {
             handleImplementsTag(p_tagLocation);
         }
+        else if ("replaces".equals(p_tagName)) {
+            handleReplacesTag(p_tagLocation);
+        }
         else if ("import".equals(p_tagName))
         {
             handleImportTag(p_tagLocation);
@@ -788,6 +794,16 @@
     }
 
     /**
+     * @param p_tagLocation location of the {@code replaces} tag
+     * @throws IOException
+     */
+    protected void handleReplacesTag(Location p_tagLocation)
+        throws IOException
+    {
+      addError(p_tagLocation, REPLACES_TAG_IN_SUBCOMPONENT);
+    }
+
+    /**
      * @param p_tagLocation location of the {@code import} tag
      * @throws IOException
      */
Index: src/main/java/org/jamon/util/InternalJavaCompiler.java
===================================================================
--- src/main/java/org/jamon/util/InternalJavaCompiler.java	(.../releases/jamon-processor/jamon-processor-2.3.4)	(revision 2774)
+++ src/main/java/org/jamon/util/InternalJavaCompiler.java	(.../trunk/jamon/jamon-processor)	(revision 2774)
@@ -22,6 +22,8 @@
 
 import java.io.ByteArrayOutputStream;
 import java.io.PrintStream;
+import java.io.PrintWriter;
+import java.io.StringWriter;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.util.List;
@@ -42,10 +44,21 @@
         m_compiler = m_compilerClass.newInstance();
         m_compile = m_compilerClass.getMethod("compile",
                                               (new String [0]).getClass());
-        // check if we can invoke the compile method
-        m_compile.invoke(m_compiler, new Object[] { new String[] { "-version" } });
+        verifyCompiler();
     }
 
+    private void verifyCompiler() throws NoSuchMethodException,
+            IllegalAccessException, InvocationTargetException
+    {
+        // check if we can invoke the compile method, but redirect output
+        Method compileWithWriter =
+            m_compilerClass.getMethod("compile", String[].class, PrintWriter.class);
+        compileWithWriter.invoke(
+            m_compiler,
+            new String[] { "-version" },
+            new PrintWriter(new StringWriter()));
+    }
+
     public String compile(String [] p_javaFiles)
     {
         String [] cmdline = new String[p_javaFiles.length + m_compilerArgs.size()];
Index: src/site/xdoc/changes.xml
===================================================================
--- src/site/xdoc/changes.xml	(.../releases/jamon-processor/jamon-processor-2.3.4)	(revision 2774)
+++ src/site/xdoc/changes.xml	(.../trunk/jamon/jamon-processor)	(revision 2774)
@@ -6,6 +6,14 @@
   <properties><title>Changes in Jamon Processor</title></properties>
   <body>
     <section name="Changes in Jamon Processor">
+      <subsection name="Release ??? (???)">
+        <ul>
+          <li>
+            Templates with constrained type parameters are now processed properly.
+            Fixes <a href="http://sourceforge.net/support/tracker.php?aid=3300744">3300744</a>.
+          </li>
+        </ul>
+      </subsection>
       <subsection name="Release 2.3.4 (2011-03-13)">
         <ul>
           <li>
Index: pom.xml
===================================================================
--- pom.xml	(.../releases/jamon-processor/jamon-processor-2.3.4)	(revision 2774)
+++ pom.xml	(.../trunk/jamon/jamon-processor)	(revision 2774)
@@ -9,13 +9,13 @@
     </parent>
     <artifactId>jamon-processor</artifactId>
     <name>jamon-processor</name>
-    <version>2.3.4</version>
+    <version>trunk-SNAPSHOT</version>
     <packaging>jar</packaging>
     <description>Jamon template to java processor</description>
     <scm>
-        <url>http://jamon.svn.sourceforge.net/viewvc/jamon/releases/jamon-processor/jamon-processor-2.3.4</url>
-        <connection>scm:svn:https://jamon.svn.sourceforge.net/svnroot/jamon/releases/jamon-processor/jamon-processor-2.3.4</connection>
-        <developerConnection>scm:svn:https://jamon.svn.sourceforge.net/svnroot/jamon/releases/jamon-processor/jamon-processor-2.3.4</developerConnection>
+        <url>http://jamon.svn.sourceforge.net/viewvc/jamon/trunk/jamon/${artifactId}/</url>
+        <connection>scm:svn:https://jamon.svn.sourceforge.net/svnroot/jamon/trunk/jamon/${artifactId}/</connection>
+        <developerConnection>scm:svn:https://jamon.svn.sourceforge.net/svnroot/jamon/trunk/jamon/${artifactId}/</developerConnection>
     </scm>
     <distributionManagement>
         <site>
@@ -53,6 +53,7 @@
             <plugin>
                 <artifactId>jamon-nodegen-plugin</artifactId>
                 <groupId>org.jamon</groupId>
+                <version>trunk-SNAPSHOT</version>
                 <executions>
                     <execution>
                         <id>nodegen</id>
