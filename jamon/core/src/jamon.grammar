/*
 * The contents of this file are subject to the Mozilla Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * The Original Code is Jamon code, released February, 2003.
 *
 * The Initial Developer of the Original Code is Jay Sachs.  Portions
 * created by Jay Sachs are Copyright (C) 2003 Jay Sachs.  All Rights
 * Reserved.
 *
 * Contributor(s): Ian Robertson
 */

Package
  org.jamon;

Helpers
  lower = ['a'..'z'];
  upper = ['A'..'Z'];
  letter = [[lower + upper] + '_'];
  digit = ['0'..'9'];
  letter_or_digit = letter | digit;
  period = '.';
  ht  = 0x0009;
  lf  = 0x000a;
  ff  = 0x000c;
  cr  = 0x000d;
  sp  = ' ';
  nl = lf | cr | cr lf;
  hs = [sp + ht];
  ws = [[[hs + lf] + ff] + cr];
  argsep = ';'; // could be nl ...
  all = [0x0000 .. 0xFFFF];
  all_except_nl = [all - [lf + cr]];
  pct = '%';
  all_except_nl_or_pct = [[all - [lf + cr]] - pct];
  q = '"';
  bs = '\';
  pipe = '|';
  quoted = q ([all-[q+bs]]* | (bs all))* q;
  sq = 39;
  hex = [digit + [['A' .. 'F'] + ['a' .. 'f']]];
  squoted = sq (([all-[sq+bs]]) | (bs all) | (bs 'u' hex hex hex hex)) sq;
  gt = '>';
  lt = '<';
  slash = '/';
  hash = '#';

States
  body,
  doc,
  bad,
  def,
  method,
  abstract_method,
  override,
  imports,
  abstract,
  extends,
  emit,
  class,
  java,
  jline,
  call,
  multifragmentcall,
  multifragmentcallexp,
  multifragmentcallbody,
  argexp,
  callexp,
  args,
  parent_args,
  parent_argexp,
  escape,
  escape_directive,
  literal,
  alias,
  farginit;

Tokens

  {body -> farginit} farg_start_begin = '<%frag';
  {farginit -> args} farg_start_done = '>';
  {farginit -> body} farg_start_end = ws* '/>' ws*;
  {args -> body} args_end = '</%args>' ws*;
  {args -> body} farg_end = '</%frag>' ws*;

  {body -> extends} extends_start = '<%extends' ws+;

  {body -> escape_directive} escape_directive_start = '<%escape' ws+;
  {escape_directive} escaping_start = hash;
  {escape_directive} escaping = letter;
  {escape_directive -> body} escape_directive_end = ws* gt ws*;

  {body -> abstract} abstract_start = '<%abstract';
  {abstract} fixed = ws+ 'fixed';
  {abstract -> body} abstract_end = '>' ws*;

  {body -> parent_args} inherited_args_start = '<%xargs>';
  {parent_args -> body} inherited_args_end = '</%xargs>' ws*;

  {body -> class} class_start = '<%class>' ws*;
  {class -> body} class_end = ws* '</%class>' ws*;
  {body -> args} args_start = '<%args>';
  {body -> imports} import_start = '<%import>';
  {imports -> body} import_end = '</%import>' ws*;
  {body -> imports} implements_start = '<%implements>';
  {imports -> body} implements_end = '</%implements>' ws*;
  {body -> java} java_start = '<%java>' ws*;
  {java -> body} java_end = ws* '</%java>' ws*;
  {args,imports} dot = period;
  {args -> argexp, parent_args -> parent_argexp,alias} arrow = '=>' hs*;
  {call,multifragmentcall,multifragmentcallbody,args,farginit,imports,parent_args,extends,alias} white_space = ws*;
  {call,multifragmentcall,multifragmentcallbody,args,parent_args,farginit,imports,def,extends,method,abstract_method,override,alias} identifier = letter letter_or_digit*;
  {call} child_call = '*CHILD';

  {body -> emit} emit_start = '<%' ws+;
  {emit -> body, escape -> body} emit_end = ws* '%>';
  {emit -> escape} escape_delimiter = hash;
  {escape} escape_code = letter;

  {emit} emit_expr =
      ( [all - [[[q + pct] + hash] + sq]]
      | quoted
      | squoted
      | pct [all - gt]
      )*;

  {jline -> body} outjava = nl;
  {jline} expr = all_except_nl*;
   // FIXME: line ending ...
  {argexp, parent_argexp} argexpr = ([all - [argsep+q]] | quoted | squoted)*;
  {argexp -> args,parent_argexp -> parent_args, args, parent_args}
      donearg = hs* argsep ws*;

  {java} java_stmts =
       ( [all - [q + lt]]
       | quoted
       | squoted
       | '<' [all - slash]
       | '</' [all - '%']
       | '</%' [all - 'j']
       | '</%j' [all - 'a']
       | '</%ja' [all - 'v']
       | '</%jav' [all - 'a']
       | '</%java' [all - gt] )*;

  {class} class_content =
       ( [all - [q + lt]]
       | quoted
       | squoted
       | '<' [all - slash]
       | '</' [all - '%']
       | '</%' [all - 'c']
       | '</%c' [all - 'l']
       | '</%cl' [all - 'a']
       | '</%cla' [all - 's']
       | '</%clas' [all - 's']
       | '</%class' [all - gt] )*;

  {body} percent = pct;
  {body} text = all_except_nl_or_pct;
  {body} ignorable_newline = bs nl;
  {body} newline = nl;

  {body -> literal} litstart = '<%LITERAL>';
  {literal} literal_text =
       (    [all - '<']
       | '<' [all - '/']
       | '</' [all - '%']
       | '</%' [all - 'L']
       | '</%L' [all - 'I']
       | '</%LI' [all - 'T']
       | '</%LIT' [all - 'E']
       | '</%LITE' [all - 'R']
       | '</%LITER' [all - 'A']
       | '</%LITERA' [all - 'L']
       | '</%LITERAL' [all - '>'] )*;
  {literal -> body} litend = '</%LITERAL>';

  {args} brackets = '[' (hs)* ']';
  {body,multifragmentcallbody -> body} fragment_call_end = '</&>';
  {call -> callexp, multifragmentcall -> multifragmentcallexp} carrow = '=>' hs*;
  {body -> call} fragment_call_start = '<&|' ws*;
  {body -> call} call_start = '<&' ws*;
  {multifragmentcall -> multifragmentcallbody, call -> body} call_end = ws* '&>';
  {callexp -> call, multifragmentcallexp -> multifragmentcall} param_expr =
       ([all - [argsep + [q + '&']]] | quoted | squoted | '&' [all - '>'])*;
  {multifragmentcall,call,imports,alias} semi = ';';
  {multifragmentcall,call,extends,alias} pathsep = slash;
  {multifragmentcall,call,extends,alias} updir = period period slash;

  {body -> multifragmentcall} multi_fragment_call_init = '<&||' ws*;


  {multifragmentcallbody} named_farg_init = '<|';
  {multifragmentcallbody -> body} named_farg_done = '>';
  {body -> multifragmentcallbody} named_farg_end = '</|>';

  {body -> def} def_start = '<%def' hs+;
  {body} def_end = '</%def>' ws*;
  {def -> body, method -> body, abstract_method -> body, override -> body, extends -> body} gt = hs* gt ws*;


  {body -> method} method_start = '<%method' hs+;
  {body} method_end = '</%method>' ws*;

  {body -> abstract_method} abstract_method_start = '<%absmeth' hs+;
  {body} abstract_method_end = '</%absmeth>' ws*;

  {body -> override} override_start = '<%override' hs+;
  {body} override_end = '</%override>' ws*;

  {body -> doc} doc_start = '<%doc>';
  {doc -> body} doc_body = ([all - '<']
              | '<' [all-slash]
              | '</' [all-'%']
              | '</%' [all-'d']
              | '</%d' [all-'o']
              | '</%do' [all-'c']
              | '</%doc' [all-'>'])* '</%doc>' ws*;

  {body -> alias} alias_start = '<%alias>';
  {alias -> body} alias_end = '</%alias>' ws*;

  {body -> bad} bad_token = '<%' [[all - ws] - gt];
  {bad -> body} rest_of_token = [all - ws]+ gt;

Ignored Tokens

  white_space,ignorable_newline;

Productions

  template = component* partial_jline? ;

  base_component =
              {body} text
            | {bad} bad_token rest_of_token?
            | {doc} doc_start doc_body
            | {newline} newline
            | {percent} percent
            | {literal} litstart literal_text litend
            | {java} java
            | {jline} jline
            | {emit} emit
            | {call} call
            | {fragment_call} fragment_call
            | {multi_fragment_call} multi_fragment_call
            | {args} args
            | {farg} farg
            ;

  component = base_component
            | {alias} aliases
            | {escape} escape_directive_start escaping_start escaping escape_directive_end
            | {imports} imports
            | {implements} implements
            | {def} def
            | {class} class_tag
            | {extends} extends_start path gt
            | {abstract} abstract_start fixed? abstract_end
            | {method} method
            | {abstract_method} abstract_method
            | {override} override
            | {inherited_use} inherited_use
            ;

  aliases = alias_start alias* alias_end;

  alias = alias_name arrow path semi;

  alias_name = {root} pathsep | {id} identifier;

  override_component = {base} base_component | {inherited_use} inherited_use;

  def = def_start identifier gt base_component* def_end;

  method = method_start identifier gt base_component* method_end;

  abstract_method = abstract_method_start identifier gt abstract_method_args* abstract_method_end;
  abstract_method_args = {args} args | {farg} farg;

  override = override_start identifier gt override_component* override_end;

  call = call_start path param* semi? call_end
       | {child} call_start child_call call_end
       ;

  fragment_call = fragment_call_start path param* semi? call_end base_component* fragment_call_end;

  multi_fragment_call = multi_fragment_call_init path param* semi? call_end named_farg* fragment_call_end;
  named_farg = named_farg_init identifier named_farg_done base_component* named_farg_end;

  imports = import_start import* import_end;

  implements = implements_start implement* implements_end;

  import = name semi;

  implement = name semi;

  args = args_start arg* args_end;

  class_tag = class_start class_content* class_end;

  farg = farg_start arg* farg_end
       | {argless} farg_tag;

  farg_start = farg_start_begin identifier farg_start_done;

  farg_tag = farg_start_begin identifier farg_start_end;

  java = java_start java_stmts java_end;

  jline = expr outjava;

  partial_jline = expr;

  emit = emit_start emit_expr escape? emit_end;

  escape = escape_delimiter escape_code;

  path = {alias} aliased_path
       | {rel} updir_path* relative_path
       | {abs} absolute_path;

  relative_path = identifier absolute_path?;

  absolute_path = pathsep relative_path;

  aliased_path = identifier? pathsep absolute_path;

  updir_path = updir;

  arg = type [name]: identifier default? donearg;

  parent_arg = [name]: identifier default? donearg;

  param = semi identifier carrow param_expr;

  default = arrow argexpr;

  name = {simple} identifier
       | {qualified} identifier dot name;

  type = name brackets*;

  inherited_use = inherited_args_start parent_arg* inherited_args_end;
