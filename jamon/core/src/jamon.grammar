Package
  org.jamon;

Helpers
  lower = ['a'..'z'];
  upper = ['A'..'Z'];
  letter = lower | upper;
  digit = ['0'..'9'];
  letter_or_digit = letter | digit | '_';
  period = '.';
  ht  = 0x0009;
  lf  = 0x000a;
  ff  = 0x000c;
  cr  = 0x000d;
  sp  = ' ';
  nl = lf | cr | cr lf;
  hs = [sp + ht];
  ws = [[hs + lf] + ff];
  argsep = ';'; // could be nl ...
  all = [0x0000 .. 0xFFFF];
  all_except_nl = [all - [lf + cr]];
  q = '"';
  bs = '\';
  pipe = '|';
  quoted = q ([all-[q+bs]]* | (bs all))* q;
  gt = '>';
  lt = '<';
  pct = '%';
  slash = '/';

States
  start,
  body,
  def,
  imports,
  emit,
  java,
  jline,
  call,
  argexp,
  callexp,
  args,
  farginit;

Tokens

  {start -> farginit,body -> farginit} farg_start_begin = '<%farg';
  {farginit -> args} farg_start_done = '>';
  {args -> body} args_end = '</%args>';
  {args -> body} farg_end = '</%farg>';
  {start -> args, body -> args} args_start = '<%args>';
  {start ->imports,body -> imports} import_start = '<%import>';
  {imports -> body} import_end = '</%import>';
  {start ->java,body -> java} java_start = '<%java>' ws*;
  {java -> body} java_end = ws* '</%java>';
  {args,imports} dot = period;
  {args -> argexp} arrow = '=>' hs*;
  {call,args,farginit,imports} white_space = ws*;
  {call,args,farginit,imports,def} identifier = letter letter_or_digit*;

  {start -> emit,body -> emit} emit_start = '<%' ws+;
  {emit -> body} emit_end = ws* '%>';
  {emit} escape = pipe lower;

  {emit} emit_expr =
      ( [all - [[q + pct] + pipe]]
      | quoted
      | pct [all - gt]
      | pipe [all - lower]
      | pipe lower ws* [all - [pct + ws]]
      | pipe lower ws* pct [all - [gt + ws]] )*;

  {start -> jline} injava = pct hs*;
  {jline -> start} outjava = hs* nl;
  {jline} expr = all_except_nl*;
   // fixme: line ending ...
  {argexp} argexpr = ([all - [argsep+q]] | quoted)*;
  {argexp -> args,args} donearg = hs* argsep ws*;

  {java} java_stmts =
       ( [all - [q + lt]]
       | quoted
       | '<' [all - slash]
       | '</' [all - '%']
       | '</%' [all - 'j']
       | '</%j' [all - 'a']
       | '</%ja' [all - 'v']
       | '</%jav' [all - 'a']
       | '</%java' [all - gt] )*;

  {body,start -> body} text = all_except_nl;
  {start,body -> start} newline = nl;

  {args} brackets = '[' (hs)* ']';
  {start -> body,body} fragment_call_end = '</&>';
  {call -> callexp} carrow = '=>' hs*;
  {start -> call, body -> call} fragment_call_start = '<|&' ws*;
  {start -> call,body -> call} call_start = '<&' ws*;
  {call -> body} call_end = ws* '&>';
  {callexp -> call} param_expr =
       ([all - [argsep + [q + '&']]] | quoted | '&' [all - '>'])*;
  {call} semi = ';';
  {call} pathsep = slash;

  {start -> def,body -> def} def_start = '<%def' hs+;
  {body,start} def_end = '</%def>';
  {def -> body} gt = hs* gt;

  {start -> body,body} doc =
       '<%doc>' ([all - '<']
              | '<' [all-slash]
              | '</' [all-'%']
              | '</%' [all-'d']
              | '</%d' [all-'o']
              | '</%do' [all-'c']
              | '</%doc' [all-'>'])* '</%doc>';

Ignored Tokens

  white_space,doc;

Productions

  template = component* partial_jline? ;

  base_component =
              {body} text
            | {newline} newline
            | {java} java
            | {jline} jline
            | {emit} emit
            | {call} call
            | {fragment_call} fragment_call
            | {args} args
            | {farg} farg
            ;

  component = base_component
            | {imports} imports
            | {def} def
            ;

  def = def_start identifier gt base_component* def_end;

  call = call_start path param* call_end;

  fragment_call = fragment_call_start path param* call_end base_component* fragment_call_end;

  imports = import_start name* import_end;

  args = args_start arg* args_end;

  farg = farg_start arg* farg_end;

  farg_start = farg_start_begin identifier farg_start_done;

  java = java_start java_stmts java_end;

  jline = injava expr outjava;

  partial_jline = injava expr;

  emit = emit_start emit_expr escape? emit_end;

  path = {simple} pathsep? identifier | {qualified} path pathsep identifier;

  arg = type [name]: identifier default? donearg;

  param = semi identifier carrow param_expr;

  default = arrow argexpr;

  name = {simple} identifier
       | {qualified} name dot identifier;

  type = name brackets*;
