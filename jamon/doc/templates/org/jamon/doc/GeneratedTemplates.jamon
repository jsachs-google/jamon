<%extends _Base>
<%override title>Jamon Generated Templates</%override>
<%class>
  protected Section currentSection() { return Section.DOCUMENTATION; }
</%class>

<h2>Generated Template Classes</h2>

Generated classes are the output of the processor, and have the
following relationships to the template sources:
<ul>
  <li>
    The class name is the same as the name of the template
    source file excluding any filename extension (i.e. a suffix
    starting with '.')
  </li>
  <li>
    The package of the class maps directly to the directory path
    from the template source directory to the template.
  </li>
  <li>
    The generated class has a <code>render</code> method whose
    arguments are the required arguments declared in the
    template. The order of declaration in the template
    determines the order in the <code>render</code> method.
  </li>
  <li>
    A <code>makeRenderer</code> method taking the same parameters as <code>render</code>
  <!-- make mention of makeRenderable -->
  <li>
    Optional arguments in the template
    generate <code>setXXX<code> methods in the class.
  </li>
</ul>

For example, suppose there is a template <code>MyTmpl</code> in the
directory <code>tmpls/org/foo</code>, the template source directory is
set to <code>tmpls</code>, and <code>MyTmpl</code> contains the
declarations

<pre><&| /org/jamon/escape/Html &><%LITERAL><%args>
  int i;
  String s => "yes";
  java.math.BigDecimal someNumber => null;
  boolean b;
</%args></%LITERAL></&></pre>

A simplified sketch (showing only the pertinent public methods) of the
generated class would be:

<pre class="java"><&| /org/jamon/escape/Html &>\
  package org.foo;

  import org.jamon.escaping.Escaping;

  public class MyTmpl
    extends org.jamon.AbstractTemplateProxy
  {
    public void render(int i, boolean b)
      throws java.io.IOException { ... }

    public Renderer makeRenderer(int i, boolean b)
      throws java.io.IOException { ... }

    public MyTmpl setS(String s)
      throws java.io.IOException { ... }

    public MyTmpl setSomeNumber(java.math.BigDecimal someNumber)
      throws java.io.IOException { ... }

    public MyTmpl writeTo(java.io.Writer p_writer)
      throws java.io.IOException { ... }

    public MyTmpl escapeWith(Escaping escaping) { ... }

    public MyTmpl autoFlush(boolean autoFlush)
      throws java.io.IOException { ... }

  }</&></pre>

If one template inherits from another, then:
<ul>
  <li>
    The generated class of the parent template will be abstract, and
    will not have <code>render</code> or <code>makeRenderer</code>
    methods.
  </li>

  <li>
    The generated class of the child template will extend the
    generated class of the parent template.
  </li>

  <li>
    Any setter methods for optional arguments declared in the parent
    template will be declared to return the generated class for the
    parent, not the child.
  </li>

  <li>
    The generated class for the parent template will define a public
    abstract inner class named <code>ParentRenderer</code>, which will
    have:

    <ul>
      <li>
        A render method taking the required arguments for the parent
        template (including any required arguments for the parent
        template's ancestors, if any).
      </li>

      <li>
        <code>setXXX<code> methods for each of the parent templates
        optional argument (including any optional arguments for the
        parent template's ancestors, if any).
      </li>

      <li>
        If the parent template itself extends another template (which
        we'll call the grandparent template), a
        <code>makeParentRender</code> method taking as arguments the
        required arguments declared by the parent template, and
        returning an object whose type is the inner
        <code>ParentRenderer</code> class of the grandparent
        template's generated class.
      </li>
    </ul>
  </li>

  <li>
    If the child template is a final template (i.e. does not contain a
    <code>&lt;&amp; *CHILD &amp;&gt;</code> call), then it's generated
    class will contain a <code>makeParentRenderer</code> method which
    takes as arguments the required arguments declared by the child
    template, and returns an object whose type is the inner
    <code>ParentRenderer</code> class of the parent template's generated class.
  </li>
</ul>

For example, if <code>/org/foo/ParentTmpl</code> contained the
declarations

<pre><&| /org/jamon/escape/Html &><%LITERAL><%args>
  int i;
  String s => "yes";
  Integer count;
</%args></%LITERAL></&></pre>

then the generated class <code>org.foo.ParentTmpl</code> would look
something like:

<pre class="java"><&| /org/jamon/escape/Html &>\
  package org.foo;

  import org.jamon.escaping.Escaping;

  public abstract class ParentTmpl
    extends org.jamon.AbstractTemplateProxy
  {
    public ParentTmpl setS(String s)
      throws java.io.IOException { ... }

    public abstract class ParentRenderer
    {
      public ParentTmpl setS(String s)
        throws java.io.IOException { ... }

      public void render(int i, Integer count)
        throws java.io.IOException { ... }

      public ParentRenderer writeTo(java.io.Writer writer)
        throws java.io.IOException { ... }

      public ParentRenderer escapeWith(Escaping escaping) { ... }

      public ParentRenderer autoFlush(boolean autoFlush)
        throws java.io.IOException { ... }
    }
  }</&></pre>

Moreover, if <code>/org/foo/ChildTmpl</code> contained the
declarations

<pre><&| /org/jamon/escape/Html &><%LITERAL><%extends ParentTmpl>
<%args>
  long t;
  java.math.BigDecimal amount => new BigDecimal(0);
  double x;
</%args></%LITERAL></&></pre>

then the generated class <code>org.foo.ChildTmpl</code> would look
something like:

<pre class="java"><&| /org/jamon/escape/Html &>\
  package org.foo;

  import org.jamon.escaping.Escaping;

  public abstract class ChildTmpl
    extends org.foo.ParentTmpl
  {
    public void render(int i, Integer count, long t, double x)
      throws java.io.IOException { ... }

    public Renderer makeRenderer(int i, Integer count, long t, double x)
      throws java.io.IOException { ... }

    public ChildTmpl setAmount(java.math.BigDecimal amount)
      throws java.io.IOException { ... }

    public ChildTmpl writeTo(java.io.Writer p_writer)
      throws java.io.IOException { ... }

    public ChildTmpl escapeWith(Escaping escaping) { ... }

    public ChildTmpl autoFlush(boolean autoFlush)
      throws java.io.IOException { ... }

    public ParentTmpl.ParentRenderer makeParentRenderer(long t, double x)
      throws java.io.IOException { ... }
  }</&></pre>

An instantiated template is a <b>thread-safe</b> object, and may
safely be used by concurrent threads.
