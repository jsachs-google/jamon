<%extends _TutorialBase>
<%args>
  String output;
</%args>

<%override title>Jamon Tutorial - Template Inheritance: Composing Template Output</%override>

<h2>Jamon Tutorial - Template Inheritance: Composing Template Output</h2>

A Jamon template can extend another Jamon template. Inheritance in Jamon, however, works differently than in Java. A parent (super) template declares that it will <em>include</em> the output of a sub-template by
<ol>
<li>
    declaring it is a parent template by specifying the
    <code>&lt;%abstract></code> tag
<li>
    including the tag <code>&lt;&amp; *CHILD &amp;></code> in the Jamon
    text where the output of the child template should be inserted.
</ol>

<p>
For example, the template <a href="InheritanceParent.jamon" class="file">
<code>InheritanceParent</code></a>, shown below, declares the
<code>&lt;&amp; *CHILD &amp;></code> where it wants to include the
child template's output. The parent template takes care of the
HTML header as well as the page's header banner while the child
template simply fills in the body.

    <& _TutorialTemplateInclude; fileName => "InheritanceParent"; &>
<p>
The child template declares that it extends the parent template by including the tag
<pre class="template">
<code>&lt;%extends InheritanceParent></code>
</pre>
If the parent template is in a different directory, then the <code>extends</code> tag must specify the path to the parent template.
<pre class="template">
<code>&lt;%extends ../InheritanceParent></code>
</pre>
The example template below,
<a href="InheritanceChild.jamon" class="file">
<code>InheritanceChild</code></a> extends <code>InheritanceTemplate</code>
and provides subject text that is included in the output of the parent template.

    <& _TutorialTemplateInclude; fileName => "InheritanceChild" &>

This template would be invoked from Java with the class
<a href="InheritanceSimpleTut9.java" class="file">
InheritanceSimpleTut9.java</a>
    <& _TutorialJavaFileInclude; fileName => "InheritanceSimpleTut9" &>

To invoke a derived template, the Java class has two options:
<ol><li>
call the <code>render()</code> method on the derived template and
provide <em>all</em> the arguments required by both the derived
and parent template, or
<li>
call <code>makeParentRenderer()</code> on the derived template, passing
the arguments required by the derived template only and then call
<code>render()</code> on the object returned by
<code>makeParentRenderer()</code>, providing the arguments expected by
the parent template.
</ol>
In the above example, the code calls <code>makeParentRenderer()</code>
and then <code>render()</code>, passing the required <code>Writer</code>
instance to <code>render</code>.

<h2>Inheritance with template arguments</h2>
Both the parent and child templates may take arguments. To specify
arguments, the parent and child templates simply include a
<code>&lt;%args></code> ... <code>&lt;/%args></code> tag.
<p>
By default, arguments in the parent template are not visible to
the child template.
They can be made visible to code in the child
      template by declaring them in <code>&lt;%xargs&gt;</code>
      ... <code>&lt;/%xargs&gt;</code> blocks.
<p>
For example, consider the parent template
<a href="InheritanceParentWArgs.jamon" class="file">
<code>InheritanceParentWArgs</code></a>. It defines arguments
<code>userAccount</code> and <code>title</code>.

    <& _TutorialTemplateInclude; fileName => "InheritanceParentWArgs" &>

The child template can only access these arguments by including
<pre class="template">
<%LITERAL>
<%xargs>
  userAccount;
  title => "special of the week";
&lt/%xargs>
</%LITERAL>
</pre>

Notice that only the name of the arguments should be
listed. This is because the types of the arguments are already
specified in the parent class. Also note, however, that any
<em>optional</em> arguments can have their default values redefined in
the child template.
<p>
A complete example of a child template,
<a href="InheritanceChildWArgs.jamon" class="file">
<code>InheritanceChildWArgs</code></a>.
is below.

    <& _TutorialTemplateInclude; fileName => "InheritanceChildWArgs" &>


<h3>Invoking a derived template</h3>
The two choices for invoking a derived template, as described earlier, are
<ol>
<li>
   the Java code can call the <code>render()</code> method on the derived
   template and provide <em>all</em> the arguments that are required
   by the child template as well as all arguments required by the parent
   template, or
<li>the code may also call the <code>makeParentRenderer()</code> method on
   the derived template, provide the arguments required by the
   child template, and then call render on the
   <code>InheritanceParentWArgs.ParentRenderer</code> object returned
   by <code>makeParentRenderer()</code> method and provide the arguments
   required by the parent template.
</ol>

The second approach allows the developer to separate the handling of
the derived template from the parent template. This allows the generic
processing of the parent template to be handled in a controller object
while the specific processing of the child templates can be handled in
separate Java classes.

<p>
The class <a href="User.java" class="file"><code>User</code></a> implements
invoking the child template through the second approach described above.

<& _TutorialJavaFileInclude; fileName => "User" &>
<p>
The output from the template is
<pre class="tty"><% output %></pre>

<p>
