<%extends _TutorialSampleBase>
<%class>
  protected int tutorialStage() { return 9; }
</%class>

<%args>
  String output;
</%args>

<%override title>Jamon Tutorial - Template Inheritance: Composing Template Output</%override>

<h2>Jamon Tutorial - Template Inheritance: Composing Template Output</h2>

Jamon template inheritance allows a template to declare that it can
<em>include</em> the output of a <em>child</em> template that extends it.
(There are other benefits of inheritence as well, which will be explained
in the next tutorial section.)

<p>
The benefits of template inclusion are obvious: a containing
template, for example, can set up the header, footer, and
navigation bar of a web page while the included
template can provide the body of the page. Template inheritance makes
this inclusion easy: a parent template can set up the page
layout while the child template simply declares that it extends the
parent in order to have its output included by the parent.
<p>
For a template to declare that it supports inheritance it must specify the tag
<pre class="template"> <code>&lt;%abstract></code></pre>
Then, where the parent template wants to include the output of a derived, or child, template, it must specify the tag
<pre class="template"> <code>&lt;&amp;* CHILD &amp;></code></pre>

<p>
For example, the template <a href="InheritanceParent.jamon" class="file">
<code>InheritanceParent</code></a>, shown below, declares the
<code>&lt;&amp; *CHILD &amp;></code> where it wants to include the
child template's output. The parent template takes care of the
HTML header as well as the page's header banner while the child
template simply fills in the body.

    <& _TutorialTemplateInclude; fileName => "InheritanceParent"; &>
<p>
The child template declares that it extends the parent template by including the tag
<pre class="template">
<code>&lt;%extends InheritanceParent></code>
</pre>
If the parent template is in a different directory, then the <code>extends</code> tag must specify the path to the parent template.
<pre class="template">
<code>&lt;%extends ../InheritanceParent></code>
</pre>
The example template below,
<a href="InheritanceChild.jamon" class="file">
<code>InheritanceChild</code></a> extends <code>InheritanceTemplate</code>
and provides subject text that is included in the output of the parent template.

    <& _TutorialTemplateInclude; fileName => "InheritanceChild" &>

This template would be invoked from Java with the class
<a href="InheritanceSimpleTut9.java" class="file">
InheritanceSimpleTut9.java</a>
    <& _TutorialJavaFileInclude; fileName => "InheritanceSimpleTut9" &>


<h2>Inheritance with template arguments</h2>
Both the parent and child templates may take arguments. To specify
arguments, the parent and child templates simply include a
<code>&lt;%args></code> ... <code>&lt;/%args></code> tag.
<p>
By default, arguments in the parent template are not visible to
the child template.
They can be made visible to code in the child
      template by declaring them in <code>&lt;%xargs&gt;</code>
      ... <code>&lt;/%xargs&gt;</code> blocks.
<p>
For example, consider the parent template
<a href="InheritanceParentWArgs.jamon" class="file">
<code>InheritanceParentWArgs</code></a>. It defines arguments
<code>userAccount</code> and <code>title</code>.

    <& _TutorialTemplateInclude; fileName => "InheritanceParentWArgs" &>

The child template can only access these arguments by including
<pre class="template">
<%LITERAL>
<%xargs>
  userAccount;
  title => "special of the week";
&lt/%xargs>
</%LITERAL>
</pre>

Notice that only the name of the arguments should be
listed. This is because the types of the arguments are already
specified in the parent class. Also note, however, that any
<em>optional</em> arguments can have their default values redefined in
the child template.
<p>
A complete example of a child template,
<a href="InheritanceChildWArgs.jamon" class="file">
<code>InheritanceChildWArgs</code></a>, is below.

    <& _TutorialTemplateInclude; fileName => "InheritanceChildWArgs" &>


<h3>Invoking a derived template</h3>
The two choices for invoking a derived template are
<ol>
<li>
   the Java code can call the <code>render()</code> method on the derived
   template and provide <em>all</em> the arguments that are required
   by the child template as well as all arguments required by the parent
   template, or
<li>the code may also call the <code>makeParentRenderer()</code> method on
   the derived template, provide the arguments required by the
   child template, and then call render on the
   <code>InheritanceParentWArgs.ParentRenderer</code> object returned
   by <code>makeParentRenderer()</code> method and provide the arguments
   required by the parent template.
</ol>

The second approach allows the developer to separate the handling of
the derived template from the parent template. This allows the generic
processing of the parent template to be handled in a controller object
while the specific processing of the child templates can be handled in
separate Java classes.

<p>
The class <a href="User.java" class="file"><code>User</code></a> implements
invoking the child template through the second approach described above.

<& _TutorialJavaFileInclude; fileName => "User" &>
<p>
The output from the template is
<pre class="tty"><% output %></pre>

<p>
